// This file is a copy of code auto-generated by Xcode with some extensions.

import CoreML

public enum Spleeter2ModelError: Error {
    case invalidFeatureName(_ featureName: String)
}

private enum FeatureNames {
    static let vocalMask = "vocalMask"
    static let instrumentsMask = "instrumentsMask"
}

/// Model Prediction Input Type
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
final class Spleeter2ModelInput: MLFeatureProvider {
    /// magnitude as 2 × frequencyLimit × length 3-dimensional array of floats
    var magnitude: MLMultiArray

    var featureNames: Set<String> { ["magnitude"] }

    func featureValue(for featureName: String) -> MLFeatureValue? {
        if featureName == "magnitude" {
            return MLFeatureValue(multiArray: magnitude)
        }
        return nil
    }

    init(magnitude: MLMultiArray) {
        self.magnitude = magnitude
    }

    convenience init(magnitude: MLShapedArray<Float>) {
        self.init(magnitude: MLMultiArray(magnitude))
    }

    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    convenience init(magnitude: MLTensor) async {
        let shapedArray = await magnitude.shapedArray(of: Float.self)
        self.init(magnitude: MLMultiArray(shapedArray))
    }
}

/// Model Prediction Output Type
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
final class Spleeter2ModelOutput: MLFeatureProvider {
    /// Source provided by CoreML
    private let provider: MLFeatureProvider

    /// vocalsMask as 2 × frequencyLimit × length × 1 4-dimensional array of floats
    var vocalsMask: MLMultiArray {
        get throws {
            guard let multiArray = provider.featureValue(for: FeatureNames.vocalMask)?.multiArrayValue else {
                throw Spleeter2ModelError.invalidFeatureName(FeatureNames.vocalMask)
            }
            return multiArray
        }
    }

    /// vocalsMask as 2 × frequencyLimit × length × 1 4-dimensional array of floats
    var vocalsMaskShapedArray: MLShapedArray<Float> {
        get throws {
            try MLShapedArray<Float>(vocalsMask)
        }
    }

    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    var vocalsMaskTensor: MLTensor {
        get throws {
            try MLTensor(vocalsMaskShapedArray)
        }
    }

    /// instrumentsMask as 2 × frequencyLimit × length × 1 4-dimensional array of floats
    var instrumentsMask: MLMultiArray {
        get throws {
            guard let multiArray = provider.featureValue(for: FeatureNames.instrumentsMask)?.multiArrayValue else {
                throw Spleeter2ModelError.invalidFeatureName(FeatureNames.instrumentsMask)
            }
            return multiArray
        }
    }

    /// instrumentsMask as 2 × frequencyLimit × length × 1 4-dimensional array of floats
    var instrumentsMaskShapedArray: MLShapedArray<Float> {
        get throws {
            try MLShapedArray<Float>(instrumentsMask)
        }
    }

    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    var instrumentsMaskTensor: MLTensor {
        get throws {
            try MLTensor(instrumentsMaskShapedArray)
        }
    }

    var featureNames: Set<String> {
        provider.featureNames
    }

    func featureValue(for featureName: String) -> MLFeatureValue? {
        provider.featureValue(for: featureName)
    }

    init(vocalsMask: MLMultiArray, instrumentsMask: MLMultiArray) throws {
        provider = try MLDictionaryFeatureProvider(
            dictionary: [
                FeatureNames.vocalMask: MLFeatureValue(multiArray: vocalsMask),
                FeatureNames.instrumentsMask: MLFeatureValue(multiArray: instrumentsMask),
            ]
        )
    }

    init(features: MLFeatureProvider) {
        provider = features
    }
}

/// Class for model loading and prediction
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
final class Spleeter2Model {
    let model: MLModel

    /// Construct Spleeter2Model instance with an existing MLModel object.
    ///
    /// Usually the application does not use this initializer unless it makes a subclass of Spleeter2Model.
    /// Such application may want to use `MLModel(contentsOfURL:configuration:)`
    /// and `Spleeter2Model.urlOfModelInThisBundle` to create a MLModel object to pass-in.
    ///
    /// - Parameter model: MLModel object
    init(model: MLModel) {
        self.model = model
    }

    /// Construct Spleeter2Model instance with explicit path to mlmodelc file
    /// - Parameter modelURL: The file url of the model
    /// - Throws: An error that describes the problem
    convenience init(contentsOf modelURL: URL) throws {
        try self.init(model: MLModel(contentsOf: modelURL))
    }

    /// Construct a model with URL of the .mlmodelc directory and configuration
    ///
    /// - Parameters:
    ///   - modelURL: The file url of the model
    ///   - configuration: The desired model configuration
    /// - Throws: An error that describes the problem
    convenience init(contentsOf modelURL: URL, configuration: MLModelConfiguration) throws {
        try self.init(model: MLModel(contentsOf: modelURL, configuration: configuration))
    }

    /// Make an asynchronous prediction using the structured interface
    ///
    /// It uses the default function if the model has multiple functions.
    ///
    /// - Parameters:
    ///   - input: The input to the prediction as Spleeter2ModelInput
    ///   - options: prediction options
    /// - Throws: An error that describes the problem
    /// - Returns: The result of the prediction as Spleeter2ModelOutput
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, visionOS 1.0, *)
    func prediction(
        input: Spleeter2ModelInput,
        options: MLPredictionOptions = MLPredictionOptions()
    ) async throws -> Spleeter2ModelOutput {
        let outFeatures = try await model.prediction(from: input, options: options)
        return Spleeter2ModelOutput(features: outFeatures)
    }

    /// Make an asynchronous prediction using the structured interface
    ///
    /// It uses the default function if the model has multiple functions.
    ///
    /// - Parameters:
    ///   - magnitude: 2 × frequencyLimit × length 3-dimensional tensor of floats
    ///   - options: Prediction options
    /// - Throws: An error that describes the problem
    /// - Returns: The result of the prediction as Spleeter2ModelOutput
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    func prediction(
        magnitude: MLTensor,
        options: MLPredictionOptions = MLPredictionOptions()
    ) async throws -> Spleeter2ModelOutput {
        let input = await Spleeter2ModelInput(magnitude: magnitude)
        return try await prediction(input: input, options: options)
    }
}
